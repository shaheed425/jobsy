{"ast":null,"code":"// import { notificationsAPI } from '../data/api';\n\n// export class NotificationService {\n//   // Get all notifications\n//   static async getAllNotifications() {\n//     try {\n//       return await notificationsAPI.getAll();\n//     } catch (error) {\n//       throw new Error('Failed to fetch notifications: ' + error.message);\n//     }\n//   }\n\n//   // Get notifications for specific recipient\n//   static async getNotificationsForRecipient(recipient, recipientId = null) {\n//     try {\n//       const notifications = await notificationsAPI.getByRecipient(recipient, recipientId);\n//       return notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n//     } catch (error) {\n//       throw new Error('Failed to fetch recipient notifications: ' + error.message);\n//     }\n//   }\n\n//   // Create new notification\n//   static async createNotification(notificationData) {\n//     try {\n//       this.validateNotificationData(notificationData);\n//       return await notificationsAPI.create(notificationData);\n//     } catch (error) {\n//       throw new Error('Failed to create notification: ' + error.message);\n//     }\n//   }\n\n//   // Mark notification as read\n//   static async markAsRead(notificationId) {\n//     try {\n//       return await notificationsAPI.markAsRead(notificationId);\n//     } catch (error) {\n//       throw new Error('Failed to mark notification as read: ' + error.message);\n//     }\n//   }\n\n//   // Get unread notifications count\n//   static async getUnreadCount(recipient, recipientId = null) {\n//     try {\n//       const notifications = await this.getNotificationsForRecipient(recipient, recipientId);\n//       return notifications.filter(notif => !notif.isRead).length;\n//     } catch (error) {\n//       throw new Error('Failed to get unread count: ' + error.message);\n//     }\n//   }\n\n//   // Send job posting notification to all students\n//   static async notifyJobPosting(jobData) {\n//     try {\n//       return await this.createNotification({\n//         type: 'job_posting',\n//         title: `New Job Posted: ${jobData.title}`,\n//         message: `${jobData.company} has posted a new ${jobData.title} position. Apply now!`,\n//         recipient: 'all_students',\n//         priority: 'medium',\n//         relatedJobId: jobData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send job posting notification: ' + error.message);\n//     }\n//   }\n\n//   // Send application status notification\n//   static async notifyApplicationStatus(applicationData, status) {\n//     try {\n//       const statusMessages = {\n//         under_review: 'Your application is under review.',\n//         shortlisted: 'Congratulations! You have been shortlisted.',\n//         accepted: 'Congratulations! Your application has been accepted.',\n//         rejected: 'Thank you for your interest. Unfortunately, your application was not selected this time.'\n//       };\n\n//       return await this.createNotification({\n//         type: 'application_status',\n//         title: 'Application Status Update',\n//         message: `${applicationData.jobTitle} at ${applicationData.company} - ${statusMessages[status]}`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: status === 'accepted' ? 'high' : 'medium',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send application status notification: ' + error.message);\n//     }\n//   }\n\n//   // Send interview schedule notification\n//   static async notifyInterviewSchedule(applicationData, interviewDate) {\n//     try {\n//       const formattedDate = new Date(interviewDate).toLocaleDateString();\n//       const formattedTime = new Date(interviewDate).toLocaleTimeString();\n\n//       return await this.createNotification({\n//         type: 'interview_schedule',\n//         title: 'Interview Scheduled',\n//         message: `Your interview for ${applicationData.jobTitle} at ${applicationData.company} is scheduled for ${formattedDate} at ${formattedTime}.`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: 'high',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send interview schedule notification: ' + error.message);\n//     }\n//   }\n\n//   // Send deadline reminder notifications\n//   static async sendDeadlineReminders() {\n//     try {\n//       // This would typically be called by a scheduled job\n//       // For now, we'll implement basic logic to check for upcoming deadlines\n//       const jobs = await jobsAPI.getAll();\n//       const threeDaysFromNow = new Date();\n//       threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3);\n\n//       const upcomingDeadlines = jobs.filter(job => {\n//         const deadline = new Date(job.applicationDeadline);\n//         return deadline <= threeDaysFromNow && deadline > new Date() && job.status === 'active';\n//       });\n\n//       const notifications = [];\n//       for (const job of upcomingDeadlines) {\n//         const notification = await this.createNotification({\n//           type: 'deadline_reminder',\n//           title: 'Application Deadline Reminder',\n//           message: `Reminder: Application deadline for ${job.title} at ${job.company} is in 3 days.`,\n//           recipient: 'all_students',\n//           priority: 'medium',\n//           relatedJobId: job.id\n//         });\n//         notifications.push(notification);\n//       }\n\n//       return notifications;\n//     } catch (error) {\n//       throw new Error('Failed to send deadline reminders: ' + error.message);\n//     }\n//   }\n\n//   // Get notification statistics\n//   static async getNotificationStatistics() {\n//     try {\n//       const notifications = await notificationsAPI.getAll();\n\n//       const stats = {\n//         total: notifications.length,\n//         byType: {\n//           job_posting: notifications.filter(n => n.type === 'job_posting').length,\n//           application_status: notifications.filter(n => n.type === 'application_status').length,\n//           interview_schedule: notifications.filter(n => n.type === 'interview_schedule').length,\n//           deadline_reminder: notifications.filter(n => n.type === 'deadline_reminder').length,\n//           profile_update: notifications.filter(n => n.type === 'profile_update').length,\n//           company_verification: notifications.filter(n => n.type === 'company_verification').length\n//         },\n//         byPriority: {\n//           high: notifications.filter(n => n.priority === 'high').length,\n//           medium: notifications.filter(n => n.priority === 'medium').length,\n//           low: notifications.filter(n => n.priority === 'low').length\n//         },\n//         unreadCount: notifications.filter(n => !n.isRead).length,\n//         recentNotifications: notifications\n//           .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n//           .slice(0, 10)\n//       };\n\n//       return stats;\n//     } catch (error) {\n//       throw new Error('Failed to get notification statistics: ' + error.message);\n//     }\n//   }\n\n//   // Validate notification data\n//   static validateNotificationData(notificationData) {\n//     const requiredFields = ['type', 'title', 'message', 'recipient', 'priority'];\n\n//     for (const field of requiredFields) {\n//       if (!notificationData[field]) {\n//         throw new Error(`${field} is required`);\n//       }\n//     }\n\n//     // Validate type\n//     const validTypes = ['job_posting', 'application_status', 'interview_schedule', 'deadline_reminder', 'profile_update', 'company_verification'];\n//     if (!validTypes.includes(notificationData.type)) {\n//       throw new Error('Invalid notification type');\n//     }\n\n//     // Validate recipient\n//     const validRecipients = ['student', 'employer', 'all_students', 'all_employers'];\n//     if (!validRecipients.includes(notificationData.recipient)) {\n//       throw new Error('Invalid recipient type');\n//     }\n\n//     // Validate priority\n//     const validPriorities = ['high', 'medium', 'low'];\n//     if (!validPriorities.includes(notificationData.priority)) {\n//       throw new Error('Invalid priority level');\n//     }\n\n//     // Validate message length\n//     if (notificationData.message.length > 500) {\n//       throw new Error('Message must not exceed 500 characters');\n//     }\n//   }\n\n//   // Simulate email/SMS sending (mock implementation)\n//   static async sendEmailNotification(recipientEmail, notification) {\n//     try {\n//       // In a real implementation, this would integrate with email service\n//       console.log(`Email sent to ${recipientEmail}:`, {\n//         subject: notification.title,\n//         body: notification.message,\n//         priority: notification.priority\n//       });\n\n//       return { success: true, message: 'Email sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send email notification: ' + error.message);\n//     }\n//   }\n\n//   static async sendSMSNotification(recipientPhone, notification) {\n//     try {\n//       // In a real implementation, this would integrate with SMS service\n//       console.log(`SMS sent to ${recipientPhone}:`, {\n//         message: `${notification.title}: ${notification.message}`,\n//         priority: notification.priority\n//       });\n\n//       return { success: true, message: 'SMS sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send SMS notification: ' + error.message);\n//     }\n//   }\n// }","map":{"version":3,"names":[],"sources":["D:/jobsy/frontend/src/domain/notificationService.js"],"sourcesContent":["// import { notificationsAPI } from '../data/api';\n\n// export class NotificationService {\n//   // Get all notifications\n//   static async getAllNotifications() {\n//     try {\n//       return await notificationsAPI.getAll();\n//     } catch (error) {\n//       throw new Error('Failed to fetch notifications: ' + error.message);\n//     }\n//   }\n\n//   // Get notifications for specific recipient\n//   static async getNotificationsForRecipient(recipient, recipientId = null) {\n//     try {\n//       const notifications = await notificationsAPI.getByRecipient(recipient, recipientId);\n//       return notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n//     } catch (error) {\n//       throw new Error('Failed to fetch recipient notifications: ' + error.message);\n//     }\n//   }\n\n//   // Create new notification\n//   static async createNotification(notificationData) {\n//     try {\n//       this.validateNotificationData(notificationData);\n//       return await notificationsAPI.create(notificationData);\n//     } catch (error) {\n//       throw new Error('Failed to create notification: ' + error.message);\n//     }\n//   }\n\n//   // Mark notification as read\n//   static async markAsRead(notificationId) {\n//     try {\n//       return await notificationsAPI.markAsRead(notificationId);\n//     } catch (error) {\n//       throw new Error('Failed to mark notification as read: ' + error.message);\n//     }\n//   }\n\n//   // Get unread notifications count\n//   static async getUnreadCount(recipient, recipientId = null) {\n//     try {\n//       const notifications = await this.getNotificationsForRecipient(recipient, recipientId);\n//       return notifications.filter(notif => !notif.isRead).length;\n//     } catch (error) {\n//       throw new Error('Failed to get unread count: ' + error.message);\n//     }\n//   }\n\n//   // Send job posting notification to all students\n//   static async notifyJobPosting(jobData) {\n//     try {\n//       return await this.createNotification({\n//         type: 'job_posting',\n//         title: `New Job Posted: ${jobData.title}`,\n//         message: `${jobData.company} has posted a new ${jobData.title} position. Apply now!`,\n//         recipient: 'all_students',\n//         priority: 'medium',\n//         relatedJobId: jobData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send job posting notification: ' + error.message);\n//     }\n//   }\n\n//   // Send application status notification\n//   static async notifyApplicationStatus(applicationData, status) {\n//     try {\n//       const statusMessages = {\n//         under_review: 'Your application is under review.',\n//         shortlisted: 'Congratulations! You have been shortlisted.',\n//         accepted: 'Congratulations! Your application has been accepted.',\n//         rejected: 'Thank you for your interest. Unfortunately, your application was not selected this time.'\n//       };\n\n//       return await this.createNotification({\n//         type: 'application_status',\n//         title: 'Application Status Update',\n//         message: `${applicationData.jobTitle} at ${applicationData.company} - ${statusMessages[status]}`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: status === 'accepted' ? 'high' : 'medium',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send application status notification: ' + error.message);\n//     }\n//   }\n\n//   // Send interview schedule notification\n//   static async notifyInterviewSchedule(applicationData, interviewDate) {\n//     try {\n//       const formattedDate = new Date(interviewDate).toLocaleDateString();\n//       const formattedTime = new Date(interviewDate).toLocaleTimeString();\n\n//       return await this.createNotification({\n//         type: 'interview_schedule',\n//         title: 'Interview Scheduled',\n//         message: `Your interview for ${applicationData.jobTitle} at ${applicationData.company} is scheduled for ${formattedDate} at ${formattedTime}.`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: 'high',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send interview schedule notification: ' + error.message);\n//     }\n//   }\n\n//   // Send deadline reminder notifications\n//   static async sendDeadlineReminders() {\n//     try {\n//       // This would typically be called by a scheduled job\n//       // For now, we'll implement basic logic to check for upcoming deadlines\n//       const jobs = await jobsAPI.getAll();\n//       const threeDaysFromNow = new Date();\n//       threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3);\n\n//       const upcomingDeadlines = jobs.filter(job => {\n//         const deadline = new Date(job.applicationDeadline);\n//         return deadline <= threeDaysFromNow && deadline > new Date() && job.status === 'active';\n//       });\n\n//       const notifications = [];\n//       for (const job of upcomingDeadlines) {\n//         const notification = await this.createNotification({\n//           type: 'deadline_reminder',\n//           title: 'Application Deadline Reminder',\n//           message: `Reminder: Application deadline for ${job.title} at ${job.company} is in 3 days.`,\n//           recipient: 'all_students',\n//           priority: 'medium',\n//           relatedJobId: job.id\n//         });\n//         notifications.push(notification);\n//       }\n\n//       return notifications;\n//     } catch (error) {\n//       throw new Error('Failed to send deadline reminders: ' + error.message);\n//     }\n//   }\n\n//   // Get notification statistics\n//   static async getNotificationStatistics() {\n//     try {\n//       const notifications = await notificationsAPI.getAll();\n      \n//       const stats = {\n//         total: notifications.length,\n//         byType: {\n//           job_posting: notifications.filter(n => n.type === 'job_posting').length,\n//           application_status: notifications.filter(n => n.type === 'application_status').length,\n//           interview_schedule: notifications.filter(n => n.type === 'interview_schedule').length,\n//           deadline_reminder: notifications.filter(n => n.type === 'deadline_reminder').length,\n//           profile_update: notifications.filter(n => n.type === 'profile_update').length,\n//           company_verification: notifications.filter(n => n.type === 'company_verification').length\n//         },\n//         byPriority: {\n//           high: notifications.filter(n => n.priority === 'high').length,\n//           medium: notifications.filter(n => n.priority === 'medium').length,\n//           low: notifications.filter(n => n.priority === 'low').length\n//         },\n//         unreadCount: notifications.filter(n => !n.isRead).length,\n//         recentNotifications: notifications\n//           .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n//           .slice(0, 10)\n//       };\n\n//       return stats;\n//     } catch (error) {\n//       throw new Error('Failed to get notification statistics: ' + error.message);\n//     }\n//   }\n\n//   // Validate notification data\n//   static validateNotificationData(notificationData) {\n//     const requiredFields = ['type', 'title', 'message', 'recipient', 'priority'];\n    \n//     for (const field of requiredFields) {\n//       if (!notificationData[field]) {\n//         throw new Error(`${field} is required`);\n//       }\n//     }\n\n//     // Validate type\n//     const validTypes = ['job_posting', 'application_status', 'interview_schedule', 'deadline_reminder', 'profile_update', 'company_verification'];\n//     if (!validTypes.includes(notificationData.type)) {\n//       throw new Error('Invalid notification type');\n//     }\n\n//     // Validate recipient\n//     const validRecipients = ['student', 'employer', 'all_students', 'all_employers'];\n//     if (!validRecipients.includes(notificationData.recipient)) {\n//       throw new Error('Invalid recipient type');\n//     }\n\n//     // Validate priority\n//     const validPriorities = ['high', 'medium', 'low'];\n//     if (!validPriorities.includes(notificationData.priority)) {\n//       throw new Error('Invalid priority level');\n//     }\n\n//     // Validate message length\n//     if (notificationData.message.length > 500) {\n//       throw new Error('Message must not exceed 500 characters');\n//     }\n//   }\n\n//   // Simulate email/SMS sending (mock implementation)\n//   static async sendEmailNotification(recipientEmail, notification) {\n//     try {\n//       // In a real implementation, this would integrate with email service\n//       console.log(`Email sent to ${recipientEmail}:`, {\n//         subject: notification.title,\n//         body: notification.message,\n//         priority: notification.priority\n//       });\n      \n//       return { success: true, message: 'Email sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send email notification: ' + error.message);\n//     }\n//   }\n\n//   static async sendSMSNotification(recipientPhone, notification) {\n//     try {\n//       // In a real implementation, this would integrate with SMS service\n//       console.log(`SMS sent to ${recipientPhone}:`, {\n//         message: `${notification.title}: ${notification.message}`,\n//         priority: notification.priority\n//       });\n      \n//       return { success: true, message: 'SMS sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send SMS notification: ' + error.message);\n//     }\n//   }\n// }\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}