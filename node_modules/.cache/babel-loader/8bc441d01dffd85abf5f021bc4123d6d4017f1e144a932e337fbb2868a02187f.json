{"ast":null,"code":"import{notificationsAPI}from'../data/api';export class NotificationService{// Get all notifications\nstatic async getAllNotifications(){try{return await notificationsAPI.getAll();}catch(error){throw new Error('Failed to fetch notifications: '+error.message);}}// Get notifications for specific recipient\nstatic async getNotificationsForRecipient(recipient){let recipientId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;try{const notifications=await notificationsAPI.getByRecipient(recipient,recipientId);return notifications.sort((a,b)=>new Date(b.createdAt)-new Date(a.createdAt));}catch(error){throw new Error('Failed to fetch recipient notifications: '+error.message);}}// Create new notification\nstatic async createNotification(notificationData){try{this.validateNotificationData(notificationData);return await notificationsAPI.create(notificationData);}catch(error){throw new Error('Failed to create notification: '+error.message);}}// Mark notification as read\nstatic async markAsRead(notificationId){try{return await notificationsAPI.markAsRead(notificationId);}catch(error){throw new Error('Failed to mark notification as read: '+error.message);}}// Get unread notifications count\nstatic async getUnreadCount(recipient){let recipientId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;try{const notifications=await this.getNotificationsForRecipient(recipient,recipientId);return notifications.filter(notif=>!notif.isRead).length;}catch(error){throw new Error('Failed to get unread count: '+error.message);}}// Send job posting notification to all students\nstatic async notifyJobPosting(jobData){try{return await this.createNotification({type:'job_posting',title:\"New Job Posted: \".concat(jobData.title),message:\"\".concat(jobData.company,\" has posted a new \").concat(jobData.title,\" position. Apply now!\"),recipient:'all_students',priority:'medium',relatedJobId:jobData.id});}catch(error){throw new Error('Failed to send job posting notification: '+error.message);}}// Send application status notification\nstatic async notifyApplicationStatus(applicationData,status){try{const statusMessages={under_review:'Your application is under review.',shortlisted:'Congratulations! You have been shortlisted.',accepted:'Congratulations! Your application has been accepted.',rejected:'Thank you for your interest. Unfortunately, your application was not selected this time.'};return await this.createNotification({type:'application_status',title:'Application Status Update',message:\"\".concat(applicationData.jobTitle,\" at \").concat(applicationData.company,\" - \").concat(statusMessages[status]),recipient:'student',recipientId:applicationData.studentId,priority:status==='accepted'?'high':'medium',relatedApplicationId:applicationData.id});}catch(error){throw new Error('Failed to send application status notification: '+error.message);}}// Get notification statistics\nstatic async getNotificationStatistics(){try{const notifications=await notificationsAPI.getAll();const stats={total:notifications.length,byType:{job_posting:notifications.filter(n=>n.type==='job_posting').length,application_status:notifications.filter(n=>n.type==='application_status').length,interview_schedule:notifications.filter(n=>n.type==='interview_schedule').length,deadline_reminder:notifications.filter(n=>n.type==='deadline_reminder').length,profile_update:notifications.filter(n=>n.type==='profile_update').length,company_verification:notifications.filter(n=>n.type==='company_verification').length},byPriority:{high:notifications.filter(n=>n.priority==='high').length,medium:notifications.filter(n=>n.priority==='medium').length,low:notifications.filter(n=>n.priority==='low').length},unreadCount:notifications.filter(n=>!n.isRead).length,recentNotifications:notifications.sort((a,b)=>new Date(b.createdAt)-new Date(a.createdAt)).slice(0,10)};return stats;}catch(error){throw new Error('Failed to get notification statistics: '+error.message);}}// Validate notification data\nstatic validateNotificationData(notificationData){const requiredFields=['type','title','message','recipient','priority'];for(const field of requiredFields){if(!notificationData[field]){throw new Error(\"\".concat(field,\" is required\"));}}// Validate type\nconst validTypes=['job_posting','application_status','interview_schedule','deadline_reminder','profile_update','company_verification'];if(!validTypes.includes(notificationData.type)){throw new Error('Invalid notification type');}// Validate recipient\nconst validRecipients=['student','employer','all_students','all_employers'];if(!validRecipients.includes(notificationData.recipient)){throw new Error('Invalid recipient type');}// Validate priority\nconst validPriorities=['high','medium','low'];if(!validPriorities.includes(notificationData.priority)){throw new Error('Invalid priority level');}// Validate message length\nif(notificationData.message.length>500){throw new Error('Message must not exceed 500 characters');}}}//   // Send application status notification\n//   static async notifyApplicationStatus(applicationData, status) {\n//     try {\n//       const statusMessages = {\n//         under_review: 'Your application is under review.',\n//         shortlisted: 'Congratulations! You have been shortlisted.',\n//         accepted: 'Congratulations! Your application has been accepted.',\n//         rejected: 'Thank you for your interest. Unfortunately, your application was not selected this time.'\n//       };\n//       return await this.createNotification({\n//         type: 'application_status',\n//         title: 'Application Status Update',\n//         message: `${applicationData.jobTitle} at ${applicationData.company} - ${statusMessages[status]}`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: status === 'accepted' ? 'high' : 'medium',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send application status notification: ' + error.message);\n//     }\n//   }\n//   // Send interview schedule notification\n//   static async notifyInterviewSchedule(applicationData, interviewDate) {\n//     try {\n//       const formattedDate = new Date(interviewDate).toLocaleDateString();\n//       const formattedTime = new Date(interviewDate).toLocaleTimeString();\n//       return await this.createNotification({\n//         type: 'interview_schedule',\n//         title: 'Interview Scheduled',\n//         message: `Your interview for ${applicationData.jobTitle} at ${applicationData.company} is scheduled for ${formattedDate} at ${formattedTime}.`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: 'high',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send interview schedule notification: ' + error.message);\n//     }\n//   }\n//   // Send deadline reminder notifications\n//   static async sendDeadlineReminders() {\n//     try {\n//       // This would typically be called by a scheduled job\n//       // For now, we'll implement basic logic to check for upcoming deadlines\n//       const jobs = await jobsAPI.getAll();\n//       const threeDaysFromNow = new Date();\n//       threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3);\n//       const upcomingDeadlines = jobs.filter(job => {\n//         const deadline = new Date(job.applicationDeadline);\n//         return deadline <= threeDaysFromNow && deadline > new Date() && job.status === 'active';\n//       });\n//       const notifications = [];\n//       for (const job of upcomingDeadlines) {\n//         const notification = await this.createNotification({\n//           type: 'deadline_reminder',\n//           title: 'Application Deadline Reminder',\n//           message: `Reminder: Application deadline for ${job.title} at ${job.company} is in 3 days.`,\n//           recipient: 'all_students',\n//           priority: 'medium',\n//           relatedJobId: job.id\n//         });\n//         notifications.push(notification);\n//       }\n//       return notifications;\n//     } catch (error) {\n//       throw new Error('Failed to send deadline reminders: ' + error.message);\n//     }\n//   }\n//   // Get notification statistics\n//   static async getNotificationStatistics() {\n//     try {\n//       const notifications = await notificationsAPI.getAll();\n//       const stats = {\n//         total: notifications.length,\n//         byType: {\n//           job_posting: notifications.filter(n => n.type === 'job_posting').length,\n//           application_status: notifications.filter(n => n.type === 'application_status').length,\n//           interview_schedule: notifications.filter(n => n.type === 'interview_schedule').length,\n//           deadline_reminder: notifications.filter(n => n.type === 'deadline_reminder').length,\n//           profile_update: notifications.filter(n => n.type === 'profile_update').length,\n//           company_verification: notifications.filter(n => n.type === 'company_verification').length\n//         },\n//         byPriority: {\n//           high: notifications.filter(n => n.priority === 'high').length,\n//           medium: notifications.filter(n => n.priority === 'medium').length,\n//           low: notifications.filter(n => n.priority === 'low').length\n//         },\n//         unreadCount: notifications.filter(n => !n.isRead).length,\n//         recentNotifications: notifications\n//           .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n//           .slice(0, 10)\n//       };\n//       return stats;\n//     } catch (error) {\n//       throw new Error('Failed to get notification statistics: ' + error.message);\n//     }\n//   }\n//   // Validate notification data\n//   static validateNotificationData(notificationData) {\n//     const requiredFields = ['type', 'title', 'message', 'recipient', 'priority'];\n//     for (const field of requiredFields) {\n//       if (!notificationData[field]) {\n//         throw new Error(`${field} is required`);\n//       }\n//     }\n//     // Validate type\n//     const validTypes = ['job_posting', 'application_status', 'interview_schedule', 'deadline_reminder', 'profile_update', 'company_verification'];\n//     if (!validTypes.includes(notificationData.type)) {\n//       throw new Error('Invalid notification type');\n//     }\n//     // Validate recipient\n//     const validRecipients = ['student', 'employer', 'all_students', 'all_employers'];\n//     if (!validRecipients.includes(notificationData.recipient)) {\n//       throw new Error('Invalid recipient type');\n//     }\n//     // Validate priority\n//     const validPriorities = ['high', 'medium', 'low'];\n//     if (!validPriorities.includes(notificationData.priority)) {\n//       throw new Error('Invalid priority level');\n//     }\n//     // Validate message length\n//     if (notificationData.message.length > 500) {\n//       throw new Error('Message must not exceed 500 characters');\n//     }\n//   }\n//   // Simulate email/SMS sending (mock implementation)\n//   static async sendEmailNotification(recipientEmail, notification) {\n//     try {\n//       // In a real implementation, this would integrate with email service\n//       console.log(`Email sent to ${recipientEmail}:`, {\n//         subject: notification.title,\n//         body: notification.message,\n//         priority: notification.priority\n//       });\n//       return { success: true, message: 'Email sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send email notification: ' + error.message);\n//     }\n//   }\n//   static async sendSMSNotification(recipientPhone, notification) {\n//     try {\n//       // In a real implementation, this would integrate with SMS service\n//       console.log(`SMS sent to ${recipientPhone}:`, {\n//         message: `${notification.title}: ${notification.message}`,\n//         priority: notification.priority\n//       });\n//       return { success: true, message: 'SMS sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send SMS notification: ' + error.message);\n//     }\n//   }\n// }","map":{"version":3,"names":["notificationsAPI","NotificationService","getAllNotifications","getAll","error","Error","message","getNotificationsForRecipient","recipient","recipientId","arguments","length","undefined","notifications","getByRecipient","sort","a","b","Date","createdAt","createNotification","notificationData","validateNotificationData","create","markAsRead","notificationId","getUnreadCount","filter","notif","isRead","notifyJobPosting","jobData","type","title","concat","company","priority","relatedJobId","id","notifyApplicationStatus","applicationData","status","statusMessages","under_review","shortlisted","accepted","rejected","jobTitle","studentId","relatedApplicationId","getNotificationStatistics","stats","total","byType","job_posting","n","application_status","interview_schedule","deadline_reminder","profile_update","company_verification","byPriority","high","medium","low","unreadCount","recentNotifications","slice","requiredFields","field","validTypes","includes","validRecipients","validPriorities"],"sources":["D:/jobsy/frontend/src/domain/notificationService.js"],"sourcesContent":["import { notificationsAPI } from '../data/api';\n\nexport class NotificationService {\n  // Get all notifications\n  static async getAllNotifications() {\n    try {\n      return await notificationsAPI.getAll();\n    } catch (error) {\n      throw new Error('Failed to fetch notifications: ' + error.message);\n    }\n  }\n\n  // Get notifications for specific recipient\n  static async getNotificationsForRecipient(recipient, recipientId = null) {\n    try {\n      const notifications = await notificationsAPI.getByRecipient(recipient, recipientId);\n      return notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n    } catch (error) {\n      throw new Error('Failed to fetch recipient notifications: ' + error.message);\n    }\n  }\n\n  // Create new notification\n  static async createNotification(notificationData) {\n    try {\n      this.validateNotificationData(notificationData);\n      return await notificationsAPI.create(notificationData);\n    } catch (error) {\n      throw new Error('Failed to create notification: ' + error.message);\n    }\n  }\n\n  // Mark notification as read\n  static async markAsRead(notificationId) {\n    try {\n      return await notificationsAPI.markAsRead(notificationId);\n    } catch (error) {\n      throw new Error('Failed to mark notification as read: ' + error.message);\n    }\n  }\n\n  // Get unread notifications count\n  static async getUnreadCount(recipient, recipientId = null) {\n    try {\n      const notifications = await this.getNotificationsForRecipient(recipient, recipientId);\n      return notifications.filter(notif => !notif.isRead).length;\n    } catch (error) {\n      throw new Error('Failed to get unread count: ' + error.message);\n    }\n  }\n\n  // Send job posting notification to all students\n  static async notifyJobPosting(jobData) {\n    try {\n      return await this.createNotification({\n        type: 'job_posting',\n        title: `New Job Posted: ${jobData.title}`,\n        message: `${jobData.company} has posted a new ${jobData.title} position. Apply now!`,\n        recipient: 'all_students',\n        priority: 'medium',\n        relatedJobId: jobData.id\n      });\n    } catch (error) {\n      throw new Error('Failed to send job posting notification: ' + error.message);\n    }\n  }\n\n  // Send application status notification\n  static async notifyApplicationStatus(applicationData, status) {\n    try {\n      const statusMessages = {\n        under_review: 'Your application is under review.',\n        shortlisted: 'Congratulations! You have been shortlisted.',\n        accepted: 'Congratulations! Your application has been accepted.',\n        rejected: 'Thank you for your interest. Unfortunately, your application was not selected this time.'\n      };\n\n      return await this.createNotification({\n        type: 'application_status',\n        title: 'Application Status Update',\n        message: `${applicationData.jobTitle} at ${applicationData.company} - ${statusMessages[status]}`,\n        recipient: 'student',\n        recipientId: applicationData.studentId,\n        priority: status === 'accepted' ? 'high' : 'medium',\n        relatedApplicationId: applicationData.id\n      });\n    } catch (error) {\n      throw new Error('Failed to send application status notification: ' + error.message);\n    }\n  }\n\n  // Get notification statistics\n  static async getNotificationStatistics() {\n    try {\n      const notifications = await notificationsAPI.getAll();\n      \n      const stats = {\n        total: notifications.length,\n        byType: {\n          job_posting: notifications.filter(n => n.type === 'job_posting').length,\n          application_status: notifications.filter(n => n.type === 'application_status').length,\n          interview_schedule: notifications.filter(n => n.type === 'interview_schedule').length,\n          deadline_reminder: notifications.filter(n => n.type === 'deadline_reminder').length,\n          profile_update: notifications.filter(n => n.type === 'profile_update').length,\n          company_verification: notifications.filter(n => n.type === 'company_verification').length\n        },\n        byPriority: {\n          high: notifications.filter(n => n.priority === 'high').length,\n          medium: notifications.filter(n => n.priority === 'medium').length,\n          low: notifications.filter(n => n.priority === 'low').length\n        },\n        unreadCount: notifications.filter(n => !n.isRead).length,\n        recentNotifications: notifications\n          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n          .slice(0, 10)\n      };\n\n      return stats;\n    } catch (error) {\n      throw new Error('Failed to get notification statistics: ' + error.message);\n    }\n  }\n\n  // Validate notification data\n  static validateNotificationData(notificationData) {\n    const requiredFields = ['type', 'title', 'message', 'recipient', 'priority'];\n    \n    for (const field of requiredFields) {\n      if (!notificationData[field]) {\n        throw new Error(`${field} is required`);\n      }\n    }\n\n    // Validate type\n    const validTypes = ['job_posting', 'application_status', 'interview_schedule', 'deadline_reminder', 'profile_update', 'company_verification'];\n    if (!validTypes.includes(notificationData.type)) {\n      throw new Error('Invalid notification type');\n    }\n\n    // Validate recipient\n    const validRecipients = ['student', 'employer', 'all_students', 'all_employers'];\n    if (!validRecipients.includes(notificationData.recipient)) {\n      throw new Error('Invalid recipient type');\n    }\n\n    // Validate priority\n    const validPriorities = ['high', 'medium', 'low'];\n    if (!validPriorities.includes(notificationData.priority)) {\n      throw new Error('Invalid priority level');\n    }\n\n    // Validate message length\n    if (notificationData.message.length > 500) {\n      throw new Error('Message must not exceed 500 characters');\n    }\n  }\n}\n\n//   // Send application status notification\n//   static async notifyApplicationStatus(applicationData, status) {\n//     try {\n//       const statusMessages = {\n//         under_review: 'Your application is under review.',\n//         shortlisted: 'Congratulations! You have been shortlisted.',\n//         accepted: 'Congratulations! Your application has been accepted.',\n//         rejected: 'Thank you for your interest. Unfortunately, your application was not selected this time.'\n//       };\n\n//       return await this.createNotification({\n//         type: 'application_status',\n//         title: 'Application Status Update',\n//         message: `${applicationData.jobTitle} at ${applicationData.company} - ${statusMessages[status]}`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: status === 'accepted' ? 'high' : 'medium',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send application status notification: ' + error.message);\n//     }\n//   }\n\n//   // Send interview schedule notification\n//   static async notifyInterviewSchedule(applicationData, interviewDate) {\n//     try {\n//       const formattedDate = new Date(interviewDate).toLocaleDateString();\n//       const formattedTime = new Date(interviewDate).toLocaleTimeString();\n\n//       return await this.createNotification({\n//         type: 'interview_schedule',\n//         title: 'Interview Scheduled',\n//         message: `Your interview for ${applicationData.jobTitle} at ${applicationData.company} is scheduled for ${formattedDate} at ${formattedTime}.`,\n//         recipient: 'student',\n//         recipientId: applicationData.studentId,\n//         priority: 'high',\n//         relatedApplicationId: applicationData.id\n//       });\n//     } catch (error) {\n//       throw new Error('Failed to send interview schedule notification: ' + error.message);\n//     }\n//   }\n\n//   // Send deadline reminder notifications\n//   static async sendDeadlineReminders() {\n//     try {\n//       // This would typically be called by a scheduled job\n//       // For now, we'll implement basic logic to check for upcoming deadlines\n//       const jobs = await jobsAPI.getAll();\n//       const threeDaysFromNow = new Date();\n//       threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3);\n\n//       const upcomingDeadlines = jobs.filter(job => {\n//         const deadline = new Date(job.applicationDeadline);\n//         return deadline <= threeDaysFromNow && deadline > new Date() && job.status === 'active';\n//       });\n\n//       const notifications = [];\n//       for (const job of upcomingDeadlines) {\n//         const notification = await this.createNotification({\n//           type: 'deadline_reminder',\n//           title: 'Application Deadline Reminder',\n//           message: `Reminder: Application deadline for ${job.title} at ${job.company} is in 3 days.`,\n//           recipient: 'all_students',\n//           priority: 'medium',\n//           relatedJobId: job.id\n//         });\n//         notifications.push(notification);\n//       }\n\n//       return notifications;\n//     } catch (error) {\n//       throw new Error('Failed to send deadline reminders: ' + error.message);\n//     }\n//   }\n\n//   // Get notification statistics\n//   static async getNotificationStatistics() {\n//     try {\n//       const notifications = await notificationsAPI.getAll();\n      \n//       const stats = {\n//         total: notifications.length,\n//         byType: {\n//           job_posting: notifications.filter(n => n.type === 'job_posting').length,\n//           application_status: notifications.filter(n => n.type === 'application_status').length,\n//           interview_schedule: notifications.filter(n => n.type === 'interview_schedule').length,\n//           deadline_reminder: notifications.filter(n => n.type === 'deadline_reminder').length,\n//           profile_update: notifications.filter(n => n.type === 'profile_update').length,\n//           company_verification: notifications.filter(n => n.type === 'company_verification').length\n//         },\n//         byPriority: {\n//           high: notifications.filter(n => n.priority === 'high').length,\n//           medium: notifications.filter(n => n.priority === 'medium').length,\n//           low: notifications.filter(n => n.priority === 'low').length\n//         },\n//         unreadCount: notifications.filter(n => !n.isRead).length,\n//         recentNotifications: notifications\n//           .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n//           .slice(0, 10)\n//       };\n\n//       return stats;\n//     } catch (error) {\n//       throw new Error('Failed to get notification statistics: ' + error.message);\n//     }\n//   }\n\n//   // Validate notification data\n//   static validateNotificationData(notificationData) {\n//     const requiredFields = ['type', 'title', 'message', 'recipient', 'priority'];\n    \n//     for (const field of requiredFields) {\n//       if (!notificationData[field]) {\n//         throw new Error(`${field} is required`);\n//       }\n//     }\n\n//     // Validate type\n//     const validTypes = ['job_posting', 'application_status', 'interview_schedule', 'deadline_reminder', 'profile_update', 'company_verification'];\n//     if (!validTypes.includes(notificationData.type)) {\n//       throw new Error('Invalid notification type');\n//     }\n\n//     // Validate recipient\n//     const validRecipients = ['student', 'employer', 'all_students', 'all_employers'];\n//     if (!validRecipients.includes(notificationData.recipient)) {\n//       throw new Error('Invalid recipient type');\n//     }\n\n//     // Validate priority\n//     const validPriorities = ['high', 'medium', 'low'];\n//     if (!validPriorities.includes(notificationData.priority)) {\n//       throw new Error('Invalid priority level');\n//     }\n\n//     // Validate message length\n//     if (notificationData.message.length > 500) {\n//       throw new Error('Message must not exceed 500 characters');\n//     }\n//   }\n\n//   // Simulate email/SMS sending (mock implementation)\n//   static async sendEmailNotification(recipientEmail, notification) {\n//     try {\n//       // In a real implementation, this would integrate with email service\n//       console.log(`Email sent to ${recipientEmail}:`, {\n//         subject: notification.title,\n//         body: notification.message,\n//         priority: notification.priority\n//       });\n      \n//       return { success: true, message: 'Email sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send email notification: ' + error.message);\n//     }\n//   }\n\n//   static async sendSMSNotification(recipientPhone, notification) {\n//     try {\n//       // In a real implementation, this would integrate with SMS service\n//       console.log(`SMS sent to ${recipientPhone}:`, {\n//         message: `${notification.title}: ${notification.message}`,\n//         priority: notification.priority\n//       });\n      \n//       return { success: true, message: 'SMS sent successfully' };\n//     } catch (error) {\n//       throw new Error('Failed to send SMS notification: ' + error.message);\n//     }\n//   }\n// }\n"],"mappings":"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AAC,2BAA2B,CAAC,CAC9C,CAEA;AACA,KAAM,CAAAmE,eAAe,CAAG,CAAC,SAAS,CAAE,UAAU,CAAE,cAAc,CAAE,eAAe,CAAC,CAChF,GAAI,CAACA,eAAe,CAACD,QAAQ,CAAClD,gBAAgB,CAACb,SAAS,CAAC,CAAE,CACzD,KAAM,IAAI,CAAAH,KAAK,CAAC,wBAAwB,CAAC,CAC3C,CAEA;AACA,KAAM,CAAAoE,eAAe,CAAG,CAAC,MAAM,CAAE,QAAQ,CAAE,KAAK,CAAC,CACjD,GAAI,CAACA,eAAe,CAACF,QAAQ,CAAClD,gBAAgB,CAACe,QAAQ,CAAC,CAAE,CACxD,KAAM,IAAI,CAAA/B,KAAK,CAAC,wBAAwB,CAAC,CAC3C,CAEA;AACA,GAAIgB,gBAAgB,CAACf,OAAO,CAACK,MAAM,CAAG,GAAG,CAAE,CACzC,KAAM,IAAI,CAAAN,KAAK,CAAC,wCAAwC,CAAC,CAC3D,CACF,CACF,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}