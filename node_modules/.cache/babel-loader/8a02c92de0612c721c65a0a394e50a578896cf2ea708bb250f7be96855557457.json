{"ast":null,"code":"import { jobsAPI, studentsAPI, applicationsAPI } from '../data/api';\nimport { StudentService } from './studentService';\nexport class JobService {\n  // Get all jobs\n  static async getAllJobs() {\n    try {\n      return await jobsAPI.getAll();\n    } catch (error) {\n      throw new Error('Failed to fetch jobs: ' + error.message);\n    }\n  }\n\n  // Get job by ID\n  static async getJobById(id) {\n    try {\n      return await jobsAPI.getById(id);\n    } catch (error) {\n      throw new Error('Failed to fetch job: ' + error.message);\n    }\n  }\n\n  // Get active jobs only\n  static async getActiveJobs() {\n    try {\n      const allJobs = await jobsAPI.getAll();\n      return allJobs.filter(job => job.status === 'active' && new Date(job.applicationDeadline) > new Date());\n    } catch (error) {\n      throw new Error('Failed to fetch active jobs: ' + error.message);\n    }\n  }\n\n  // Search and filter jobs\n  static async searchJobs(filters = {}) {\n    try {\n      let jobs = await jobsAPI.getAll();\n\n      // Filter by location\n      if (filters.location) {\n        jobs = jobs.filter(job => job.location.toLowerCase().includes(filters.location.toLowerCase()));\n      }\n\n      // Filter by job type\n      if (filters.jobType) {\n        jobs = jobs.filter(job => job.jobType === filters.jobType);\n      }\n\n      // Filter by company\n      if (filters.company) {\n        jobs = jobs.filter(job => job.company.toLowerCase().includes(filters.company.toLowerCase()));\n      }\n\n      // Filter by experience level\n      if (filters.experience) {\n        jobs = jobs.filter(job => job.experience.toLowerCase().includes(filters.experience.toLowerCase()));\n      }\n\n      // Filter by salary range (basic implementation)\n      if (filters.minSalary) {\n        jobs = jobs.filter(job => {\n          const salaryMatch = job.salary.match(/\\$(\\d+,?\\d*)/);\n          if (salaryMatch) {\n            const jobMinSalary = parseInt(salaryMatch[1].replace(',', ''));\n            return jobMinSalary >= filters.minSalary;\n          }\n          return true;\n        });\n      }\n\n      // Filter by skills\n      if (filters.skills && filters.skills.length > 0) {\n        jobs = jobs.filter(job => job.skills && job.skills.some(skill => filters.skills.some(filterSkill => skill.toLowerCase().includes(filterSkill.toLowerCase()))));\n      }\n\n      // Filter by department eligibility\n      if (filters.department) {\n        jobs = jobs.filter(job => job.eligibilityCriteria && job.eligibilityCriteria.departments && job.eligibilityCriteria.departments.includes(filters.department));\n      }\n\n      // Sort by posted date (newest first)\n      jobs.sort((a, b) => new Date(b.postedDate) - new Date(a.postedDate));\n      return jobs;\n    } catch (error) {\n      throw new Error('Failed to search jobs: ' + error.message);\n    }\n  }\n\n  // Get jobs suitable for a specific student\n  static async getJobsForStudent(studentId) {\n    try {\n      const student = await studentsAPI.getById(studentId);\n      if (!student) {\n        throw new Error('Student not found');\n      }\n      const allJobs = await this.getActiveJobs();\n      return allJobs.filter(job => {\n        // Check basic eligibility\n        if (!student.isEligible) return false;\n\n        // Check if already applied\n        if (student.appliedJobs && student.appliedJobs.includes(job.id)) return false;\n\n        // Check job eligibility criteria\n        if (job.eligibilityCriteria) {\n          // Check CGPA\n          if (job.eligibilityCriteria.minCGPA && student.cgpa < job.eligibilityCriteria.minCGPA) {\n            return false;\n          }\n\n          // Check department\n          if (job.eligibilityCriteria.departments && !job.eligibilityCriteria.departments.includes(student.department)) {\n            return false;\n          }\n\n          // Check year\n          if (job.eligibilityCriteria.year && student.year < job.eligibilityCriteria.year) {\n            return false;\n          }\n        }\n        return true;\n      });\n    } catch (error) {\n      throw new Error('Failed to get jobs for student: ' + error.message);\n    }\n  }\n\n  // Get job statistics\n  static async getJobStatistics() {\n    try {\n      const jobs = await jobsAPI.getAll();\n      const applications = await applicationsAPI.getAll();\n      const stats = {\n        total: jobs.length,\n        active: jobs.filter(job => job.status === 'active').length,\n        expired: jobs.filter(job => new Date(job.applicationDeadline) < new Date()).length,\n        byType: {\n          'Full-time': jobs.filter(job => job.jobType === 'Full-time').length,\n          'Part-time': jobs.filter(job => job.jobType === 'Part-time').length,\n          'Internship': jobs.filter(job => job.jobType === 'Internship').length,\n          'Contract': jobs.filter(job => job.jobType === 'Contract').length\n        },\n        byLocation: this.groupJobsByLocation(jobs),\n        totalApplications: applications.length,\n        averageApplicationsPerJob: jobs.length > 0 ? Math.round(applications.length / jobs.length) : 0,\n        mostPopularJobs: this.getMostPopularJobs(jobs, applications)\n      };\n      return stats;\n    } catch (error) {\n      throw new Error('Failed to get job statistics: ' + error.message);\n    }\n  }\n\n  // Group jobs by location for analytics\n  static groupJobsByLocation(jobs) {\n    const locationGroups = {};\n    jobs.forEach(job => {\n      const location = job.location;\n      if (!locationGroups[location]) {\n        locationGroups[location] = 0;\n      }\n      locationGroups[location]++;\n    });\n    return locationGroups;\n  }\n\n  // Get most popular jobs based on applications\n  static getMostPopularJobs(jobs, applications) {\n    const jobApplicationCounts = {};\n    applications.forEach(app => {\n      if (!jobApplicationCounts[app.jobId]) {\n        jobApplicationCounts[app.jobId] = 0;\n      }\n      jobApplicationCounts[app.jobId]++;\n    });\n    return jobs.map(job => ({\n      ...job,\n      applicationCount: jobApplicationCounts[job.id] || 0\n    })).sort((a, b) => b.applicationCount - a.applicationCount).slice(0, 5);\n  }\n\n  // Check if application deadline is approaching\n  static isDeadlineApproaching(job, daysThreshold = 3) {\n    const deadline = new Date(job.applicationDeadline);\n    const now = new Date();\n    const diffTime = deadline - now;\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    return diffDays <= daysThreshold && diffDays > 0;\n  }\n\n  // Get recommended jobs based on student profile\n  static async getRecommendedJobs(studentId, limit = 5) {\n    try {\n      const student = await studentsAPI.getById(studentId);\n      if (!student) {\n        throw new Error('Student not found');\n      }\n      const suitableJobs = await this.getJobsForStudent(studentId);\n\n      // Score jobs based on student profile\n      const scoredJobs = suitableJobs.map(job => {\n        let score = 0;\n\n        // Score based on skill match\n        if (job.skills && student.skills) {\n          const matchingSkills = job.skills.filter(skill => student.skills.some(studentSkill => studentSkill.toLowerCase().includes(skill.toLowerCase())));\n          score += matchingSkills.length * 10;\n        }\n\n        // Score based on department match\n        if (job.eligibilityCriteria && job.eligibilityCriteria.departments && job.eligibilityCriteria.departments.includes(student.department)) {\n          score += 20;\n        }\n\n        // Score based on CGPA (higher CGPA gets bonus for competitive jobs)\n        if (job.eligibilityCriteria && job.eligibilityCriteria.minCGPA) {\n          const cgpaBonus = Math.max(0, student.cgpa - job.eligibilityCriteria.minCGPA) * 5;\n          score += cgpaBonus;\n        }\n\n        // Bonus for newer jobs\n        const daysSincePosted = (new Date() - new Date(job.postedDate)) / (1000 * 60 * 60 * 24);\n        if (daysSincePosted < 7) {\n          score += 15;\n        }\n        return {\n          ...job,\n          recommendationScore: score\n        };\n      });\n\n      // Sort by score and return top recommendations\n      return scoredJobs.sort((a, b) => b.recommendationScore - a.recommendationScore).slice(0, limit);\n    } catch (error) {\n      throw new Error('Failed to get recommended jobs: ' + error.message);\n    }\n  }\n\n  // Get job details with additional information\n  static async getJobDetails(jobId) {\n    try {\n      const job = await jobsAPI.getById(jobId);\n      if (!job) {\n        throw new Error('Job not found');\n      }\n      const applications = await applicationsAPI.getByJobId(jobId);\n      const eligibleStudents = await StudentService.getEligibleStudentsForJob(job.eligibilityCriteria);\n      return {\n        job,\n        applicationCount: applications.length,\n        eligibleStudentCount: eligibleStudents.length,\n        applications: applications.slice(0, 10),\n        // Recent applications\n        isDeadlineApproaching: this.isDeadlineApproaching(job),\n        daysUntilDeadline: Math.ceil((new Date(job.applicationDeadline) - new Date()) / (1000 * 60 * 60 * 24))\n      };\n    } catch (error) {\n      throw new Error('Failed to get job details: ' + error.message);\n    }\n  }\n}","map":{"version":3,"names":["jobsAPI","studentsAPI","applicationsAPI","StudentService","JobService","getAllJobs","getAll","error","Error","message","getJobById","id","getById","getActiveJobs","allJobs","filter","job","status","Date","applicationDeadline","searchJobs","filters","jobs","location","toLowerCase","includes","jobType","company","experience","minSalary","salaryMatch","salary","match","jobMinSalary","parseInt","replace","skills","length","some","skill","filterSkill","department","eligibilityCriteria","departments","sort","a","b","postedDate","getJobsForStudent","studentId","student","isEligible","appliedJobs","minCGPA","cgpa","year","getJobStatistics","applications","stats","total","active","expired","byType","byLocation","groupJobsByLocation","totalApplications","averageApplicationsPerJob","Math","round","mostPopularJobs","getMostPopularJobs","locationGroups","forEach","jobApplicationCounts","app","jobId","map","applicationCount","slice","isDeadlineApproaching","daysThreshold","deadline","now","diffTime","diffDays","ceil","getRecommendedJobs","limit","suitableJobs","scoredJobs","score","matchingSkills","studentSkill","cgpaBonus","max","daysSincePosted","recommendationScore","getJobDetails","getByJobId","eligibleStudents","getEligibleStudentsForJob","eligibleStudentCount","daysUntilDeadline"],"sources":["D:/jobsy/frontend/src/domain/jobService.js"],"sourcesContent":["import { jobsAPI, studentsAPI, applicationsAPI } from '../data/api';\nimport { StudentService } from './studentService';\n\nexport class JobService {\n  // Get all jobs\n  static async getAllJobs() {\n    try {\n      return await jobsAPI.getAll();\n    } catch (error) {\n      throw new Error('Failed to fetch jobs: ' + error.message);\n    }\n  }\n\n  // Get job by ID\n  static async getJobById(id) {\n    try {\n      return await jobsAPI.getById(id);\n    } catch (error) {\n      throw new Error('Failed to fetch job: ' + error.message);\n    }\n  }\n\n  // Get active jobs only\n  static async getActiveJobs() {\n    try {\n      const allJobs = await jobsAPI.getAll();\n      return allJobs.filter(job => \n        job.status === 'active' && \n        new Date(job.applicationDeadline) > new Date()\n      );\n    } catch (error) {\n      throw new Error('Failed to fetch active jobs: ' + error.message);\n    }\n  }\n\n  // Search and filter jobs\n  static async searchJobs(filters = {}) {\n    try {\n      let jobs = await jobsAPI.getAll();\n\n      // Filter by location\n      if (filters.location) {\n        jobs = jobs.filter(job => \n          job.location.toLowerCase().includes(filters.location.toLowerCase())\n        );\n      }\n\n      // Filter by job type\n      if (filters.jobType) {\n        jobs = jobs.filter(job => job.jobType === filters.jobType);\n      }\n\n      // Filter by company\n      if (filters.company) {\n        jobs = jobs.filter(job => \n          job.company.toLowerCase().includes(filters.company.toLowerCase())\n        );\n      }\n\n      // Filter by experience level\n      if (filters.experience) {\n        jobs = jobs.filter(job => \n          job.experience.toLowerCase().includes(filters.experience.toLowerCase())\n        );\n      }\n\n      // Filter by salary range (basic implementation)\n      if (filters.minSalary) {\n        jobs = jobs.filter(job => {\n          const salaryMatch = job.salary.match(/\\$(\\d+,?\\d*)/);\n          if (salaryMatch) {\n            const jobMinSalary = parseInt(salaryMatch[1].replace(',', ''));\n            return jobMinSalary >= filters.minSalary;\n          }\n          return true;\n        });\n      }\n\n      // Filter by skills\n      if (filters.skills && filters.skills.length > 0) {\n        jobs = jobs.filter(job => \n          job.skills && job.skills.some(skill => \n            filters.skills.some(filterSkill => \n              skill.toLowerCase().includes(filterSkill.toLowerCase())\n            )\n          )\n        );\n      }\n\n      // Filter by department eligibility\n      if (filters.department) {\n        jobs = jobs.filter(job => \n          job.eligibilityCriteria && \n          job.eligibilityCriteria.departments &&\n          job.eligibilityCriteria.departments.includes(filters.department)\n        );\n      }\n\n      // Sort by posted date (newest first)\n      jobs.sort((a, b) => new Date(b.postedDate) - new Date(a.postedDate));\n\n      return jobs;\n    } catch (error) {\n      throw new Error('Failed to search jobs: ' + error.message);\n    }\n  }\n\n  // Get jobs suitable for a specific student\n  static async getJobsForStudent(studentId) {\n    try {\n      const student = await studentsAPI.getById(studentId);\n      if (!student) {\n        throw new Error('Student not found');\n      }\n\n      const allJobs = await this.getActiveJobs();\n      \n      return allJobs.filter(job => {\n        // Check basic eligibility\n        if (!student.isEligible) return false;\n\n        // Check if already applied\n        if (student.appliedJobs && student.appliedJobs.includes(job.id)) return false;\n\n        // Check job eligibility criteria\n        if (job.eligibilityCriteria) {\n          // Check CGPA\n          if (job.eligibilityCriteria.minCGPA && student.cgpa < job.eligibilityCriteria.minCGPA) {\n            return false;\n          }\n\n          // Check department\n          if (job.eligibilityCriteria.departments && \n              !job.eligibilityCriteria.departments.includes(student.department)) {\n            return false;\n          }\n\n          // Check year\n          if (job.eligibilityCriteria.year && student.year < job.eligibilityCriteria.year) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    } catch (error) {\n      throw new Error('Failed to get jobs for student: ' + error.message);\n    }\n  }\n\n  // Get job statistics\n  static async getJobStatistics() {\n    try {\n      const jobs = await jobsAPI.getAll();\n      const applications = await applicationsAPI.getAll();\n\n      const stats = {\n        total: jobs.length,\n        active: jobs.filter(job => job.status === 'active').length,\n        expired: jobs.filter(job => new Date(job.applicationDeadline) < new Date()).length,\n        byType: {\n          'Full-time': jobs.filter(job => job.jobType === 'Full-time').length,\n          'Part-time': jobs.filter(job => job.jobType === 'Part-time').length,\n          'Internship': jobs.filter(job => job.jobType === 'Internship').length,\n          'Contract': jobs.filter(job => job.jobType === 'Contract').length\n        },\n        byLocation: this.groupJobsByLocation(jobs),\n        totalApplications: applications.length,\n        averageApplicationsPerJob: jobs.length > 0 ? Math.round(applications.length / jobs.length) : 0,\n        mostPopularJobs: this.getMostPopularJobs(jobs, applications)\n      };\n\n      return stats;\n    } catch (error) {\n      throw new Error('Failed to get job statistics: ' + error.message);\n    }\n  }\n\n  // Group jobs by location for analytics\n  static groupJobsByLocation(jobs) {\n    const locationGroups = {};\n    \n    jobs.forEach(job => {\n      const location = job.location;\n      if (!locationGroups[location]) {\n        locationGroups[location] = 0;\n      }\n      locationGroups[location]++;\n    });\n\n    return locationGroups;\n  }\n\n  // Get most popular jobs based on applications\n  static getMostPopularJobs(jobs, applications) {\n    const jobApplicationCounts = {};\n    \n    applications.forEach(app => {\n      if (!jobApplicationCounts[app.jobId]) {\n        jobApplicationCounts[app.jobId] = 0;\n      }\n      jobApplicationCounts[app.jobId]++;\n    });\n\n    return jobs\n      .map(job => ({\n        ...job,\n        applicationCount: jobApplicationCounts[job.id] || 0\n      }))\n      .sort((a, b) => b.applicationCount - a.applicationCount)\n      .slice(0, 5);\n  }\n\n  // Check if application deadline is approaching\n  static isDeadlineApproaching(job, daysThreshold = 3) {\n    const deadline = new Date(job.applicationDeadline);\n    const now = new Date();\n    const diffTime = deadline - now;\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    \n    return diffDays <= daysThreshold && diffDays > 0;\n  }\n\n  // Get recommended jobs based on student profile\n  static async getRecommendedJobs(studentId, limit = 5) {\n    try {\n      const student = await studentsAPI.getById(studentId);\n      if (!student) {\n        throw new Error('Student not found');\n      }\n\n      const suitableJobs = await this.getJobsForStudent(studentId);\n      \n      // Score jobs based on student profile\n      const scoredJobs = suitableJobs.map(job => {\n        let score = 0;\n        \n        // Score based on skill match\n        if (job.skills && student.skills) {\n          const matchingSkills = job.skills.filter(skill => \n            student.skills.some(studentSkill => \n              studentSkill.toLowerCase().includes(skill.toLowerCase())\n            )\n          );\n          score += matchingSkills.length * 10;\n        }\n\n        // Score based on department match\n        if (job.eligibilityCriteria && \n            job.eligibilityCriteria.departments &&\n            job.eligibilityCriteria.departments.includes(student.department)) {\n          score += 20;\n        }\n\n        // Score based on CGPA (higher CGPA gets bonus for competitive jobs)\n        if (job.eligibilityCriteria && job.eligibilityCriteria.minCGPA) {\n          const cgpaBonus = Math.max(0, student.cgpa - job.eligibilityCriteria.minCGPA) * 5;\n          score += cgpaBonus;\n        }\n\n        // Bonus for newer jobs\n        const daysSincePosted = (new Date() - new Date(job.postedDate)) / (1000 * 60 * 60 * 24);\n        if (daysSincePosted < 7) {\n          score += 15;\n        }\n\n        return { ...job, recommendationScore: score };\n      });\n\n      // Sort by score and return top recommendations\n      return scoredJobs\n        .sort((a, b) => b.recommendationScore - a.recommendationScore)\n        .slice(0, limit);\n    } catch (error) {\n      throw new Error('Failed to get recommended jobs: ' + error.message);\n    }\n  }\n\n  // Get job details with additional information\n  static async getJobDetails(jobId) {\n    try {\n      const job = await jobsAPI.getById(jobId);\n      if (!job) {\n        throw new Error('Job not found');\n      }\n\n      const applications = await applicationsAPI.getByJobId(jobId);\n      const eligibleStudents = await StudentService.getEligibleStudentsForJob(job.eligibilityCriteria);\n\n      return {\n        job,\n        applicationCount: applications.length,\n        eligibleStudentCount: eligibleStudents.length,\n        applications: applications.slice(0, 10), // Recent applications\n        isDeadlineApproaching: this.isDeadlineApproaching(job),\n        daysUntilDeadline: Math.ceil((new Date(job.applicationDeadline) - new Date()) / (1000 * 60 * 60 * 24))\n      };\n    } catch (error) {\n      throw new Error('Failed to get job details: ' + error.message);\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,WAAW,EAAEC,eAAe,QAAQ,aAAa;AACnE,SAASC,cAAc,QAAQ,kBAAkB;AAEjD,OAAO,MAAMC,UAAU,CAAC;EACtB;EACA,aAAaC,UAAUA,CAAA,EAAG;IACxB,IAAI;MACF,OAAO,MAAML,OAAO,CAACM,MAAM,CAAC,CAAC;IAC/B,CAAC,CAAC,OAAOC,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,wBAAwB,GAAGD,KAAK,CAACE,OAAO,CAAC;IAC3D;EACF;;EAEA;EACA,aAAaC,UAAUA,CAACC,EAAE,EAAE;IAC1B,IAAI;MACF,OAAO,MAAMX,OAAO,CAACY,OAAO,CAACD,EAAE,CAAC;IAClC,CAAC,CAAC,OAAOJ,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,uBAAuB,GAAGD,KAAK,CAACE,OAAO,CAAC;IAC1D;EACF;;EAEA;EACA,aAAaI,aAAaA,CAAA,EAAG;IAC3B,IAAI;MACF,MAAMC,OAAO,GAAG,MAAMd,OAAO,CAACM,MAAM,CAAC,CAAC;MACtC,OAAOQ,OAAO,CAACC,MAAM,CAACC,GAAG,IACvBA,GAAG,CAACC,MAAM,KAAK,QAAQ,IACvB,IAAIC,IAAI,CAACF,GAAG,CAACG,mBAAmB,CAAC,GAAG,IAAID,IAAI,CAAC,CAC/C,CAAC;IACH,CAAC,CAAC,OAAOX,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,+BAA+B,GAAGD,KAAK,CAACE,OAAO,CAAC;IAClE;EACF;;EAEA;EACA,aAAaW,UAAUA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACpC,IAAI;MACF,IAAIC,IAAI,GAAG,MAAMtB,OAAO,CAACM,MAAM,CAAC,CAAC;;MAEjC;MACA,IAAIe,OAAO,CAACE,QAAQ,EAAE;QACpBD,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IACpBA,GAAG,CAACO,QAAQ,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACJ,OAAO,CAACE,QAAQ,CAACC,WAAW,CAAC,CAAC,CACpE,CAAC;MACH;;MAEA;MACA,IAAIH,OAAO,CAACK,OAAO,EAAE;QACnBJ,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACU,OAAO,KAAKL,OAAO,CAACK,OAAO,CAAC;MAC5D;;MAEA;MACA,IAAIL,OAAO,CAACM,OAAO,EAAE;QACnBL,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IACpBA,GAAG,CAACW,OAAO,CAACH,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACJ,OAAO,CAACM,OAAO,CAACH,WAAW,CAAC,CAAC,CAClE,CAAC;MACH;;MAEA;MACA,IAAIH,OAAO,CAACO,UAAU,EAAE;QACtBN,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IACpBA,GAAG,CAACY,UAAU,CAACJ,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACJ,OAAO,CAACO,UAAU,CAACJ,WAAW,CAAC,CAAC,CACxE,CAAC;MACH;;MAEA;MACA,IAAIH,OAAO,CAACQ,SAAS,EAAE;QACrBP,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IAAI;UACxB,MAAMc,WAAW,GAAGd,GAAG,CAACe,MAAM,CAACC,KAAK,CAAC,cAAc,CAAC;UACpD,IAAIF,WAAW,EAAE;YACf,MAAMG,YAAY,GAAGC,QAAQ,CAACJ,WAAW,CAAC,CAAC,CAAC,CAACK,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;YAC9D,OAAOF,YAAY,IAAIZ,OAAO,CAACQ,SAAS;UAC1C;UACA,OAAO,IAAI;QACb,CAAC,CAAC;MACJ;;MAEA;MACA,IAAIR,OAAO,CAACe,MAAM,IAAIf,OAAO,CAACe,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;QAC/Cf,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IACpBA,GAAG,CAACoB,MAAM,IAAIpB,GAAG,CAACoB,MAAM,CAACE,IAAI,CAACC,KAAK,IACjClB,OAAO,CAACe,MAAM,CAACE,IAAI,CAACE,WAAW,IAC7BD,KAAK,CAACf,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACe,WAAW,CAAChB,WAAW,CAAC,CAAC,CACxD,CACF,CACF,CAAC;MACH;;MAEA;MACA,IAAIH,OAAO,CAACoB,UAAU,EAAE;QACtBnB,IAAI,GAAGA,IAAI,CAACP,MAAM,CAACC,GAAG,IACpBA,GAAG,CAAC0B,mBAAmB,IACvB1B,GAAG,CAAC0B,mBAAmB,CAACC,WAAW,IACnC3B,GAAG,CAAC0B,mBAAmB,CAACC,WAAW,CAAClB,QAAQ,CAACJ,OAAO,CAACoB,UAAU,CACjE,CAAC;MACH;;MAEA;MACAnB,IAAI,CAACsB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAI5B,IAAI,CAAC4B,CAAC,CAACC,UAAU,CAAC,GAAG,IAAI7B,IAAI,CAAC2B,CAAC,CAACE,UAAU,CAAC,CAAC;MAEpE,OAAOzB,IAAI;IACb,CAAC,CAAC,OAAOf,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,yBAAyB,GAAGD,KAAK,CAACE,OAAO,CAAC;IAC5D;EACF;;EAEA;EACA,aAAauC,iBAAiBA,CAACC,SAAS,EAAE;IACxC,IAAI;MACF,MAAMC,OAAO,GAAG,MAAMjD,WAAW,CAACW,OAAO,CAACqC,SAAS,CAAC;MACpD,IAAI,CAACC,OAAO,EAAE;QACZ,MAAM,IAAI1C,KAAK,CAAC,mBAAmB,CAAC;MACtC;MAEA,MAAMM,OAAO,GAAG,MAAM,IAAI,CAACD,aAAa,CAAC,CAAC;MAE1C,OAAOC,OAAO,CAACC,MAAM,CAACC,GAAG,IAAI;QAC3B;QACA,IAAI,CAACkC,OAAO,CAACC,UAAU,EAAE,OAAO,KAAK;;QAErC;QACA,IAAID,OAAO,CAACE,WAAW,IAAIF,OAAO,CAACE,WAAW,CAAC3B,QAAQ,CAACT,GAAG,CAACL,EAAE,CAAC,EAAE,OAAO,KAAK;;QAE7E;QACA,IAAIK,GAAG,CAAC0B,mBAAmB,EAAE;UAC3B;UACA,IAAI1B,GAAG,CAAC0B,mBAAmB,CAACW,OAAO,IAAIH,OAAO,CAACI,IAAI,GAAGtC,GAAG,CAAC0B,mBAAmB,CAACW,OAAO,EAAE;YACrF,OAAO,KAAK;UACd;;UAEA;UACA,IAAIrC,GAAG,CAAC0B,mBAAmB,CAACC,WAAW,IACnC,CAAC3B,GAAG,CAAC0B,mBAAmB,CAACC,WAAW,CAAClB,QAAQ,CAACyB,OAAO,CAACT,UAAU,CAAC,EAAE;YACrE,OAAO,KAAK;UACd;;UAEA;UACA,IAAIzB,GAAG,CAAC0B,mBAAmB,CAACa,IAAI,IAAIL,OAAO,CAACK,IAAI,GAAGvC,GAAG,CAAC0B,mBAAmB,CAACa,IAAI,EAAE;YAC/E,OAAO,KAAK;UACd;QACF;QAEA,OAAO,IAAI;MACb,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOhD,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,kCAAkC,GAAGD,KAAK,CAACE,OAAO,CAAC;IACrE;EACF;;EAEA;EACA,aAAa+C,gBAAgBA,CAAA,EAAG;IAC9B,IAAI;MACF,MAAMlC,IAAI,GAAG,MAAMtB,OAAO,CAACM,MAAM,CAAC,CAAC;MACnC,MAAMmD,YAAY,GAAG,MAAMvD,eAAe,CAACI,MAAM,CAAC,CAAC;MAEnD,MAAMoD,KAAK,GAAG;QACZC,KAAK,EAAErC,IAAI,CAACe,MAAM;QAClBuB,MAAM,EAAEtC,IAAI,CAACP,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAK,QAAQ,CAAC,CAACoB,MAAM;QAC1DwB,OAAO,EAAEvC,IAAI,CAACP,MAAM,CAACC,GAAG,IAAI,IAAIE,IAAI,CAACF,GAAG,CAACG,mBAAmB,CAAC,GAAG,IAAID,IAAI,CAAC,CAAC,CAAC,CAACmB,MAAM;QAClFyB,MAAM,EAAE;UACN,WAAW,EAAExC,IAAI,CAACP,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACU,OAAO,KAAK,WAAW,CAAC,CAACW,MAAM;UACnE,WAAW,EAAEf,IAAI,CAACP,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACU,OAAO,KAAK,WAAW,CAAC,CAACW,MAAM;UACnE,YAAY,EAAEf,IAAI,CAACP,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACU,OAAO,KAAK,YAAY,CAAC,CAACW,MAAM;UACrE,UAAU,EAAEf,IAAI,CAACP,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACU,OAAO,KAAK,UAAU,CAAC,CAACW;QAC7D,CAAC;QACD0B,UAAU,EAAE,IAAI,CAACC,mBAAmB,CAAC1C,IAAI,CAAC;QAC1C2C,iBAAiB,EAAER,YAAY,CAACpB,MAAM;QACtC6B,yBAAyB,EAAE5C,IAAI,CAACe,MAAM,GAAG,CAAC,GAAG8B,IAAI,CAACC,KAAK,CAACX,YAAY,CAACpB,MAAM,GAAGf,IAAI,CAACe,MAAM,CAAC,GAAG,CAAC;QAC9FgC,eAAe,EAAE,IAAI,CAACC,kBAAkB,CAAChD,IAAI,EAAEmC,YAAY;MAC7D,CAAC;MAED,OAAOC,KAAK;IACd,CAAC,CAAC,OAAOnD,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,gCAAgC,GAAGD,KAAK,CAACE,OAAO,CAAC;IACnE;EACF;;EAEA;EACA,OAAOuD,mBAAmBA,CAAC1C,IAAI,EAAE;IAC/B,MAAMiD,cAAc,GAAG,CAAC,CAAC;IAEzBjD,IAAI,CAACkD,OAAO,CAACxD,GAAG,IAAI;MAClB,MAAMO,QAAQ,GAAGP,GAAG,CAACO,QAAQ;MAC7B,IAAI,CAACgD,cAAc,CAAChD,QAAQ,CAAC,EAAE;QAC7BgD,cAAc,CAAChD,QAAQ,CAAC,GAAG,CAAC;MAC9B;MACAgD,cAAc,CAAChD,QAAQ,CAAC,EAAE;IAC5B,CAAC,CAAC;IAEF,OAAOgD,cAAc;EACvB;;EAEA;EACA,OAAOD,kBAAkBA,CAAChD,IAAI,EAAEmC,YAAY,EAAE;IAC5C,MAAMgB,oBAAoB,GAAG,CAAC,CAAC;IAE/BhB,YAAY,CAACe,OAAO,CAACE,GAAG,IAAI;MAC1B,IAAI,CAACD,oBAAoB,CAACC,GAAG,CAACC,KAAK,CAAC,EAAE;QACpCF,oBAAoB,CAACC,GAAG,CAACC,KAAK,CAAC,GAAG,CAAC;MACrC;MACAF,oBAAoB,CAACC,GAAG,CAACC,KAAK,CAAC,EAAE;IACnC,CAAC,CAAC;IAEF,OAAOrD,IAAI,CACRsD,GAAG,CAAC5D,GAAG,KAAK;MACX,GAAGA,GAAG;MACN6D,gBAAgB,EAAEJ,oBAAoB,CAACzD,GAAG,CAACL,EAAE,CAAC,IAAI;IACpD,CAAC,CAAC,CAAC,CACFiC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC+B,gBAAgB,GAAGhC,CAAC,CAACgC,gBAAgB,CAAC,CACvDC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EAChB;;EAEA;EACA,OAAOC,qBAAqBA,CAAC/D,GAAG,EAAEgE,aAAa,GAAG,CAAC,EAAE;IACnD,MAAMC,QAAQ,GAAG,IAAI/D,IAAI,CAACF,GAAG,CAACG,mBAAmB,CAAC;IAClD,MAAM+D,GAAG,GAAG,IAAIhE,IAAI,CAAC,CAAC;IACtB,MAAMiE,QAAQ,GAAGF,QAAQ,GAAGC,GAAG;IAC/B,MAAME,QAAQ,GAAGjB,IAAI,CAACkB,IAAI,CAACF,QAAQ,IAAI,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;IAE5D,OAAOC,QAAQ,IAAIJ,aAAa,IAAII,QAAQ,GAAG,CAAC;EAClD;;EAEA;EACA,aAAaE,kBAAkBA,CAACrC,SAAS,EAAEsC,KAAK,GAAG,CAAC,EAAE;IACpD,IAAI;MACF,MAAMrC,OAAO,GAAG,MAAMjD,WAAW,CAACW,OAAO,CAACqC,SAAS,CAAC;MACpD,IAAI,CAACC,OAAO,EAAE;QACZ,MAAM,IAAI1C,KAAK,CAAC,mBAAmB,CAAC;MACtC;MAEA,MAAMgF,YAAY,GAAG,MAAM,IAAI,CAACxC,iBAAiB,CAACC,SAAS,CAAC;;MAE5D;MACA,MAAMwC,UAAU,GAAGD,YAAY,CAACZ,GAAG,CAAC5D,GAAG,IAAI;QACzC,IAAI0E,KAAK,GAAG,CAAC;;QAEb;QACA,IAAI1E,GAAG,CAACoB,MAAM,IAAIc,OAAO,CAACd,MAAM,EAAE;UAChC,MAAMuD,cAAc,GAAG3E,GAAG,CAACoB,MAAM,CAACrB,MAAM,CAACwB,KAAK,IAC5CW,OAAO,CAACd,MAAM,CAACE,IAAI,CAACsD,YAAY,IAC9BA,YAAY,CAACpE,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACc,KAAK,CAACf,WAAW,CAAC,CAAC,CACzD,CACF,CAAC;UACDkE,KAAK,IAAIC,cAAc,CAACtD,MAAM,GAAG,EAAE;QACrC;;QAEA;QACA,IAAIrB,GAAG,CAAC0B,mBAAmB,IACvB1B,GAAG,CAAC0B,mBAAmB,CAACC,WAAW,IACnC3B,GAAG,CAAC0B,mBAAmB,CAACC,WAAW,CAAClB,QAAQ,CAACyB,OAAO,CAACT,UAAU,CAAC,EAAE;UACpEiD,KAAK,IAAI,EAAE;QACb;;QAEA;QACA,IAAI1E,GAAG,CAAC0B,mBAAmB,IAAI1B,GAAG,CAAC0B,mBAAmB,CAACW,OAAO,EAAE;UAC9D,MAAMwC,SAAS,GAAG1B,IAAI,CAAC2B,GAAG,CAAC,CAAC,EAAE5C,OAAO,CAACI,IAAI,GAAGtC,GAAG,CAAC0B,mBAAmB,CAACW,OAAO,CAAC,GAAG,CAAC;UACjFqC,KAAK,IAAIG,SAAS;QACpB;;QAEA;QACA,MAAME,eAAe,GAAG,CAAC,IAAI7E,IAAI,CAAC,CAAC,GAAG,IAAIA,IAAI,CAACF,GAAG,CAAC+B,UAAU,CAAC,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;QACvF,IAAIgD,eAAe,GAAG,CAAC,EAAE;UACvBL,KAAK,IAAI,EAAE;QACb;QAEA,OAAO;UAAE,GAAG1E,GAAG;UAAEgF,mBAAmB,EAAEN;QAAM,CAAC;MAC/C,CAAC,CAAC;;MAEF;MACA,OAAOD,UAAU,CACd7C,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACkD,mBAAmB,GAAGnD,CAAC,CAACmD,mBAAmB,CAAC,CAC7DlB,KAAK,CAAC,CAAC,EAAES,KAAK,CAAC;IACpB,CAAC,CAAC,OAAOhF,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,kCAAkC,GAAGD,KAAK,CAACE,OAAO,CAAC;IACrE;EACF;;EAEA;EACA,aAAawF,aAAaA,CAACtB,KAAK,EAAE;IAChC,IAAI;MACF,MAAM3D,GAAG,GAAG,MAAMhB,OAAO,CAACY,OAAO,CAAC+D,KAAK,CAAC;MACxC,IAAI,CAAC3D,GAAG,EAAE;QACR,MAAM,IAAIR,KAAK,CAAC,eAAe,CAAC;MAClC;MAEA,MAAMiD,YAAY,GAAG,MAAMvD,eAAe,CAACgG,UAAU,CAACvB,KAAK,CAAC;MAC5D,MAAMwB,gBAAgB,GAAG,MAAMhG,cAAc,CAACiG,yBAAyB,CAACpF,GAAG,CAAC0B,mBAAmB,CAAC;MAEhG,OAAO;QACL1B,GAAG;QACH6D,gBAAgB,EAAEpB,YAAY,CAACpB,MAAM;QACrCgE,oBAAoB,EAAEF,gBAAgB,CAAC9D,MAAM;QAC7CoB,YAAY,EAAEA,YAAY,CAACqB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QAAE;QACzCC,qBAAqB,EAAE,IAAI,CAACA,qBAAqB,CAAC/D,GAAG,CAAC;QACtDsF,iBAAiB,EAAEnC,IAAI,CAACkB,IAAI,CAAC,CAAC,IAAInE,IAAI,CAACF,GAAG,CAACG,mBAAmB,CAAC,GAAG,IAAID,IAAI,CAAC,CAAC,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;MACvG,CAAC;IACH,CAAC,CAAC,OAAOX,KAAK,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,6BAA6B,GAAGD,KAAK,CAACE,OAAO,CAAC;IAChE;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}